#### 正文
##### 可重入性
定义：
可重入是指同一个线程当外层函数获取到锁时，内层函数可以直接再次获取该锁。
看不懂没关系，我们先来看一个例子。
前一篇文章我们说过一妻多夫的生活案例（没有看过的小伙伴建议先看前一篇），小伙伴们想一下，假设兄弟四人中老大先拿到这块砖（锁），那么他当天就有资格进入房间（同步方法/代码块），这没毛病，毕竟早起的鸟儿有虫吃。在老大持有这块砖的过程中，他可以在房间随意走动，他甚至可以去厕所、浴室，卧室等等，并且都不需要再重新去获取那块砖（锁）。
这就叫可重入，一旦线程获取到对象锁（砖），再去访问该对象锁的所有同步方法（浴室、卧室）时，就不用再去重新竞争锁资源。
```
public synchronized void testSync1(){
    System.out.println("我进来了方法1");
    testSync1();
}

public static void main(String[] args) {
    new SyncDemo().testSync1();
}
```
#### 不可中断性
***
定义：
一旦锁被某个线程获取，其他线程再想进入同步方法/代码块，就只能等待，直到持有锁的那个线程释放这个锁，如果一直不释放这个锁，那么其他线程只能一直等待下去。
synchronized释放锁的方式有两种 1.正常结束 2.抛出异常

##### 使用synchronized修饰代码块时
反汇编后的内容如下：

<img src="https://user-images.githubusercontent.com/59634423/122518551-ef3bec00-d043-11eb-8b24-cd39cd41ace6.png" width=700 height=500 />
从上面的内容我们可以看到，JVM采用monitorenter、monitorexit这两个指令来实现线程同步。
可以把monitorenter理解为 加锁 操作，monitorexit则是 释放锁。每个对象都会维护一个计数器，当一个线程获取到锁（执行monitorenter）后，计数器 加1；释放锁后（执行monitorexit指令），计数器 减1，当计数器的值为 0时，该对象锁被释放，其他等待中的线程开始竞争该锁。


##### 使用synchronized修饰方法时
方法级的同步是隐式的，也就是说不需要通过字节码指令来控制的。JVM通过 ACC_SYNCHRONIZED 访问标志来区分一个方法是否是同步方法。
当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，说明该方法为同步方法，请求的线程需要先获取monitor（监视器锁），然后才能执行方法，在方法执行后再释放monitor。方法执行期间，其他任何线程因为无法获得monitor而处于阻塞状态。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那么在异常被抛到方法外面之前监视器锁会被自动释放。
***
分析完原理，再看synchronized的作用就清晰了，synchronized主要有三个作用
1. 原子性：一个操作或则多个操作要么全部执行完成，要么都不执行。Java内存模型提供了monitorenter和monitorexit指令来隐式的实现原子操作，从而实现线程之间互斥的访问同步代码块，将多个小原子操作合成大原子。
2. 可见性：当多个线程访问同一个变量时，一个线程修改了该变量的值，其他线程能够立即看得到修改后的值。synchronized 解锁之前，必须将工作内存中的数据同步到主内存，因此在解锁后，其它线程操作该变量时每次都可以看到被修改后的值。
3. 有序性：程序执行的顺序按照代码的先后顺序执行。这其实和 as-if-serial 有关。
